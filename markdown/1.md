# Клон Packman &mdash; создаём проект

Эта статья покажет, как настроить и запустить простую программу на SFML. В программе будут заложен основной цикл приложения. Пример к статье [доступен на github](../packman_1). Так он выглядит:

![скриншот](images/preview_packman_1.png)

### Выбор Visual Studio

Предпочтительно использовать последнюю выпущенную версию Visual Studio Community Edition, и выбирать английскую локализацию. Если вы установили другую локализацию (например, русскую), её лучше удалить и всё же поставить английскую. В противном случае появится целый ряд проблем с терминологией, поиском информации в сети и использованием статей и книг. Не секрет, что большая часть актуальной информации о программировании в сети &mdash; на английском языке, и лучше, если интерфейс среды разработки тоже будет английским.

### Загрузка SFML

Актуальную версию можно найти на [www.sfml-dev.org](http://www.sfml-dev.org/download.php). Выбирайте 32-х или 64-хбитную библиотеку для нужной версии Visual Studio.

![скриншот](images/donwload.png)

### Новый C++ проект

Для создания проекта в Visual Studio нужно выбрать один из шаблонов, указать имя и путь к директории проекта. Для наших целей подходят шаблоны "Console Application" и "Empty Project". После создания следует

- перейти к файлу, название которого совпадает с именем проекта &mdash; там была размещена функция `main()`
- добавить включение заголовочного файла ```SFML/Graphics.hpp```
```cpp
#include <SFML/Graphics.hpp>
```
- нарисовать круг с помощью библиотеки SFML

В рамках первого примера код можно скопировать прямо в функцию main().

##### Код рисования круга
```cpp
sf::RenderWindow window(sf::VideoMode(800, 600), "Window Title");
sf::CircleShape shape;
shape.setRadius(20);
shape.setFillColor(sf::Color::Green);
shape.setPosition(100, 0);

while (window.isOpen())
{
    sf::Event event;
    while (window.pollEvent(event))
    {
        if (event.type == sf::Event::Closed)
        {
            window.close();
        }
    }
    window.clear();
    window.draw(shape);
    window.display();
}
```

### Запускаем код

TODO:

- добавляем путь к include (через локальные настройки)
- добавляем путь к lib
- добавляем отладочные библиотеки
- добавляем макрос SFML_DYNAMIC
- добавляем команду copy в PostBuild шаг сборки

### Исследуем код

В листинге мы сделали несколько вещей:

- создали объект класса `sf::RenderWindow`, абстрагирующий работу с окном
- создали и настроили объект класса `sf::CircleShape`, абстрагирующий работу с фигурой &mdash; кругом
- запустили основной цикл игры

[Основной цикл игры (gameprogrammingpatterns.com)](http://gameprogrammingpatterns.com/game-loop.html) &mdash; это шаблон проектирования кода, который применяется практически в каждой игре. Он диктует, как должна выглядеть основная процедура игры (`main` в языках C/C++): сначала происходит инициализация, а затем начинается цикл, выход из которого происходит непосредственно перед закрытием приложения. Общая схема игрового цикла:

![Схема](images/gameloop_chart.png)

Основной цикл пока что очень прост:

 - перед рисованием кадра происходит опрос внешних событий. Если события есть, то метод `window.pollEvent` вернёт булево значение `true` и скопирует информацию о событии в 1-й аргумент.

```cpp
sf::Event event;
while (window.pollEvent(event))
{
    if (event.type == sf::Event::Closed)
    {
        window.close();
    }
}
```

 - игрового состояния в данный момент нет, поэтому обновлять нечего

 - после опроса событий окно очищается (заливается чёрным цветом), затем на нём рисуется фигура, затем очередной кадр отправляется операционной системе, которая отобразит кадр окна на экране

```cpp
window.clear();
window.draw(shape);
// метод display отдаёт кадр операционной системе, а также может ожидать
// сигнала вертикальной синхронизации монитора (vsync).
window.display();
```

Современные операционные системы обычно обновляют экран с частотой 60Гц, и такой же частоты ожидают от приложений. Поэтому на выполнение одной итерации цикла отведено `1.0 / 60.0 = 0.016(6)` секунд, то есть чуть более 16 миллисекунд. Естественно, все современные игры стремятся уложиться в этот интервал независимо от сложности моделируемого игрового мира.

### Система коодинат SFML

Отсчёт координат в SFML, как и в большинстве графических библиотек, начинается с левого верхнего угла.

- мы установили (100,20) как двумерную координату круга
- радиус круга сделали равным 20
- однако, центр круга расположен в точке (120,40), потому что метод `shape.setPosition` изменил положение левого верхнего угла фигуры.

![иллюстрация](images/metrics.png)

### Разгружаем функцию main

Мы можем сделать функцию main более чистой, если выделим выполняемые ею задачи в отдельные функции. При этом каждая функция должна выполнять ровно одну подзадачу &mdash; это логично, ведь имя функции как раз и должно говорить о задаче, выполняемой этой функцией.

Введём дополнительные функции initPackman (инициализирует круг), render (рисуюет кадр) и handleEvents (обрабатывает нажатие на кнопку закрытия окна):

```cpp
#include <SFML/Graphics.hpp>

void initPackman(sf::CircleShape & shape)
{
    shape.setRadius(20);
    shape.setFillColor(sf::Color::Green);
    shape.setPosition(100, 0);
}

void handleEvents(sf::RenderWindow & window)
{
    sf::Event event;
    while (window.pollEvent(event))
    {
        if (event.type == sf::Event::Closed)
        {
            window.close();
        }
    }
}

void render(sf::RenderWindow & window, sf::CircleShape & shape)
{
    window.clear();
    window.draw(shape);
    window.display();
}

int main(int, char *[])
{
    sf::RenderWindow window(sf::VideoMode(800, 600), "Window Title");
    sf::CircleShape packman;
    initPackman(packman);

    while (window.isOpen())
    {
        handleEvents(window);
        render(window, packman);
    }

    return 0;
}
```

### Далее

- [второй пример](2.md)
- [Tutorial по работе с окном (sfml-dev.org)](http://www.sfml-dev.org/tutorials/2.3/window-window.php)